##lab2实验报告


> ####Thinking 3.1
我们注意到我们把宏函数的函数体写成了 do { // ... } while(0)的形式，而不是仅仅写成形如 {// ... } 的语句块，这样的写法好处是什么？

* 首先，最大的好处就是，当我们在使用的这个宏的时候，必须在宏后面直接添加一个‘；’，  
这样，我们可以不必考虑宏与函数的差别，无差别的使用。这是区别于{}形式的最大好处。
* 其次，和{}一样，都具有括住宏定义的用途，防止二义性。
* 消除了goto语句的使用，可用break代替

> ####Thinking 3.2
了解了二级页表页目录自映射的原理之后，我们知道， Win2k 内核的
虚存管理也是采用了二级页表的形式，其页表所占的 4M 空间对应的虚存起始地址
为 0xC0000000，那么，它的页目录的起始地址是多少呢？

* 起始地址是0xC0000000，该地址对应的页表项为第C0000000 >> 12，则页目录的起始地址是  
0xC0000000+（0xC0000000>>12）*4 = 0xC0300000

>####Thinking 3.3
思考一下 tlb_out 汇编函数，结合代码阐述一下跳转到 NOFOUND
的流程？

> LEAF(tlb_out)  
    6 nop  
    7 mfc0 k1,CP0_ENTRYHI  
    8 mtc0 a0,CP0_ENTRYHI  
    9 nop  
    10 tlbp  
    11 nop    
    12 nop    
    13 nop    
    14 nop  
    15 mfc0 k0,CP0_INDEX  
    16 bltz k0,NOFOUND  
    17 nop  
    18 mtc0 zero,CP0_ENTRYHI  
    19 mtc0 zero,CP0_ENTRYLO0  
    20 nop  
    21 tlbwi  
    22 NOFOUND:  
    23  
    24 mtc0 k1,CP0_ENTRYHI  
    25  
    26 j ra  
    27 nop  
    28 END(tlb_out) 
    
* 该汇编函数跳转到NOFOUND的流程：  
       tlbp指令检测到no TLB entry matches,便将CP0_INDEX寄存器最高位变成1，  
       然后后边如果检测到CP0_INDEX为负的（首位为1），则表示未找到，跳转到NOFOUND
      
####难点
   1. 首先是掌握内存管理方面的基础原理，万丈高楼平地起，只有充分的理解统一的框架原理，才能进行下一步。
   2. 然后是读，OS的实验与之前的实验不同，敲代码的功夫不多，主要是理解别人（先辈们）的  
   代码，所以当你把所有的代码理顺了，补充就水倒渠成了。
   3. 实际上当你掌握了最先的两点之后，接下写就是小菜一碟了，只是务必要细心，不要敲错东西。
   4. 123点就是lab2正确的打开方式，我一开始在vim中打开实验代码，试图直接上手，浪费一番  
   功夫后发现，必须从根本的一点一点来，哪两步顺序反了都不行。
   5. 理解一步中我认为比较难的就是理解代码中的数据结构  
      其一是Pde， pte， 这两者从宏定义来看是同一东西，所以关于这两个类型的强制转换看似无用，其实是真实  
      模拟概念意义上的转换，很重要，强调一遍，很重要，就像pgdir_walk这个函数中的语句，每个语句之间的转换  
      关系都是精华。
      其二是Page页表的构建于page_free_list链表的特别之处，说实话，当我第一次读懂这个奇怪的数据结构  
      的目标之后，我觉得这个代码的设计者太神了，创建了一个只可以单向遍历的双向链表，一开始没懂的时候  
      读注释说这个链表的特点时我都觉得不可思议。
      理解一步中还有一个比较的难的是宏定义。  
      queue.h中的list操作宏定义和mmu.h中虚实地址转换和页表与地址转换宏定义是非常重要的。请细细的读。
   6. 做完上面几点，工具和理论都具备了，开始码代码。
   
注：对于虚实地址转换我做了一个PPT，放在了github中。