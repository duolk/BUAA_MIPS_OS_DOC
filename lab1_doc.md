##OS-lab1实验报告
>####Thinking 1.1
>思考以下几条指令有何作用？
>
> - `ls -l`
> - `mv test1.c test2.c`
> - `cp test1.c teest2.c`
> - `cd ..`

	* 列出当前目录下所有非隐藏文件及其详细信息
	* 将当前目录下的test1.c文件重命名为test2.c
	* 复制当前目录下test1.c文件到当前目录下为teest2.c
	* 打开当前目录的父目录（/目录的父目录为其本身）


>####Thinking 1.2
>思考`grep`指令的用法，例如如何查找项目中所有的宏？
>如何查找指定的函数名？

	grep命令-r参数代表递归查找，在某一项目中递归查找所有的宏可以使用下面的命令：
		grep -r '#define' 项目目录路径
	类似地，查找指定的函数名：
		grep -r '函数名'   项目目录路径
	
	当然grep和正则表达式相结合还有很多高级功能。

***
[grep传送门](http://www.linuxso.com/command/grep.html)
***

>####Thinking 1.3
>思考`gcc`的`-Werror`和`-Wall`两个参数在项目开发中的意义。

	* -Wall表示尽可能多的产生警告信息
	   从某种程度上说，加上该参数可以给出“几乎”所有的编译器警告，在我们编写工程时，免不了调试工作，
	   加上该参数可以帮助你注意到一些很可能的出错点，当程序运行出现问题时，我们可以首先考虑编译器
	   报出worning的地方。
	* -Werror表示把所有的警告当作错误处理
	   Werror我认为可以在某些对安全性稳定性要求很高的工程中使用，因为它不允许一点点的警告发生，这样
	   可以提高编写程序时的严谨性，从而保证程序的正常运行。



>####Thinking 2.1
> - 深夜，小明在做操作系统实验。困意一阵阵袭来，小明睡倒在了键盘上。等到小明早上醒来的时候，他惊恐地发现，他把一个重要的代码文件`printf.c`删除掉了。苦恼的小明向你求助，你觉得怎样能帮他把代码文件恢复呢？
> - 正在小明苦恼的时候，小红主动请缨帮小明解决问题。小红很爽快地在键盘上敲下了 `git rm printf.c`，这下事情更复杂了，现在你又该如何处理才能弥补小红的过错呢？
> - 处理完代码文件，你正打算去找小明说他的文件已经恢复了，但突然发现小明的仓库里有一个叫 `Tucao.txt`，你好奇地打开一看，发现是吐槽操作系统实验的，且该文件已经被添加到暂存区了，面对这样的情况，你该如何设置才能使`Tucao.txt`在不从工作区删除的情况下不会被`git commit`指提交到版本库？

	1.	分析：此时文件只是在本地工作区被删除了，在版本库的暂存区里还存在被删除的printf.c文件，
	但这是保存着最后一次提交以前的状态，也就是说，我们可以使用
    git checkout -- file
	将该文件恢复到它上次add到暂存区的状态，因此在上次add至删除该文件中间的这段时间所做的修改将会全部丢失。
	git checkout -- file所做的事情，就是丢弃工作区中所做的修改(包括删除操作)，恢复到暂存区的状态。

	2.	分析：从上面分析可以知道，小红敲下命令前，工作区没有printf.c文件，而暂存区和版本库都存在最后一次
	提交的版本，当小红执行命令之后，即删除了暂存区中的printf.c版本，此时使用git checkout -- file便不会
	奏效了，因为git在暂存区找不到该文件，怎么办呢？现在可以使用
	git reset HEAD file
	来将暂存区中的修改撤销掉，撤销完之后，我们可以根据处理第一个问题的步骤来解决。

	3.	分析：此时想要删除暂存区的printf.c版本，即需要把tucao.txt文件剔出监视变为untracked状态，可以使用
	以下命令删除暂存区文件而不影响工作区：
	git rm --cache file

>####Thinking 2.2
>思考下面四个描述，你觉得哪些正确，哪些错误，请给出你参考的资料或实验证据。
>
1. 克隆时所有分支均被克隆，但只有HEAD指向的分支被检出。
2. 克隆出的工作区中执行 `git log`、 `git status`、 `git checkout`、 `git commit` 等操作不会去访问远程版本库。
3. 克隆时只有远程版本库 HEAD 指向的分支被克隆。
4. 克隆后工作区的默认分支处于 master 分支。
***
	1. 正确
	   首先分支的“检出”是指远程服务器仓库上的分支有对应的本地分支
	   为了验证上面的说法是否正确，我决定用借助github平台建立一个
	   远程git仓库，首先是注册一个github账号，建立default仓库，
	   然后开启虚拟机linux系统，配置ssh key：
`liduokun@ubuntu $: ssh-keygen -t rsa`

	   此时该虚拟机系统可以向该远程仓库push了。
	   克隆远程仓库到本地：
`git clone git@github.com:duolk/default.git`
		
	   然后开始建立不同的分支为测试做准备，这里有个小问题：
	   在开始版本库为空的时候我们使用如下命令并不能看到branch结构：
`git branch -a`
	
	   后来发现只有第一次commit之后master分支才会出现。
	   再建立一个名为test1的分支，打开一个无关的目录，再次克隆远程仓库，然后进入该本地版本库目录：
`git branch -a`
	   
	* 	master
		remotes/origin/HEAD -> origin/master
		remotes/origin/master
		remotes/origin/test1
	可见的确是各分支被克隆，但只有HEAD指向的被检出。
	（有个问题还不知道为什么，用putty clone版本库的时候总是超时？）
***
	2. 正确
	   首先可以确定的是git status，git checkout，git commit不会访问远程版本库，git status，记录的
	   是本地版本库中工作区的修改情况（包括add，commit），这些信息没有push到远程版本库去，所以根本不需
	   要访问远程版本库。git checkout只是在本地切换分支，push到远程版本库后可以认为HEAD是默认指向master
	   分支，不必访问远程版本库。而git commit是提交到本地，也不会访问远程版本库。至于git log，我认为是
	   和远程版本库隔绝的，因为如果可以直接访问远程版本库的话，我们可以根据git log去到“未来”--即远程的最
	   新的状态，就不必需要git pull这个命令了。
	3. 错误，由1可以得出结论。
	4. 正确，我在第一个克隆的本地工作区中创建完test1分支之后，切换到了test1分支中并push到远程版本库中，
	   而在第二个本地工作区中克隆下的版本库中HEAD默认指向了master分支。